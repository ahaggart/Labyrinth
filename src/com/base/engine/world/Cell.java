package com.base.engine.world;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Color;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;
import org.newdawn.slick.SpriteSheet;

import com.base.engine.attachments.*;
import com.base.engine.consumables.*;
import com.base.engine.core.BaseGame;
import com.base.engine.tileEffects.*;

import java.util.ArrayList;

public class Cell
{
	public static final int width = 16;
	
	private static int displayMode = 3;
	/*
		0 = active cell display
		1 = cell color display
		2 = cell z display
		3 = cell status display
	*/
	private int x, y, z;
	private int status;
	private boolean perm;
	private boolean select = false;//another debug tool, used to flag a cell
	private boolean active = true;//flag to tell if a cell should receive updates
	private boolean remove = false;//flag to tell if a cell should be removed from the grid
	private Cell[] neighbors;//list of references to neighboring cells
	/*
		0 = up
		1 = right
		2 = down
		3 = left
	*/
	private Color color;
	//each cell holds a reference to the cell grid so it can add additional cells when necessary
	private ArrayList<Cell> grid;
	
	//debug tools to trace poll() stacks if they overflow
	private static ArrayList<Cell> stackTracer = new ArrayList<Cell>();
	private static String stackTracker = "";
	
	private Attachment attached;
	private ArrayList<TileEffect> effects;
	
	private static SpriteSheet wall;
	private static SpriteSheet floor;
	private static SpriteSheet cracked;
	int rx = (int)(Math.random() * 3);
	
	private Image img;

	public Cell(int x, int y)
	{
		this.x = x;
		this.y = y;
		this.z = (int)(Math.random() * 256);
		neighbors = new Cell[4];
//		this.grid = grid;
		//assign this cell a random color
		color = Color.white;
		status = (int)(Math.random() * 2);
		if(d2() < 4 * width * width)
			status = 0;
		
		if(wall == null)
		{
			try {
				Image wallSRC = new Image("img/stone_brick.png");
				wall = new SpriteSheet(wallSRC, 16, 16, 2, 0);
				Image floorSRC = new Image("img/dirt_floor.png");
				floor = new SpriteSheet(floorSRC, 16, 16, 2, 0);
				Image crackedSRC = new Image("img/dirt_cracked.png");
				cracked = new SpriteSheet(crackedSRC, 16, 16, 2, 0);
			} catch (SlickException e) {
				e.printStackTrace();
			}
		}
		img = getSprite(status);
		effects = new ArrayList<TileEffect>();
		
		if(status == 0)
		{
			if(Math.random() < 0.05)
			{
				double rand = Math.random();
				if(rand > 0.97)
					attached = randomItem();
				else
					attached = new Coin();
			}
		}
	}	
	
	public Cell(int x, int y, ArrayList<Cell> grid)
	{
		this.x = x;
		this.y = y;
		this.z = (int)(Math.random() * 256);
		neighbors = new Cell[4];
		this.grid = grid;
		//assign this cell a random color
		color = Color.white;
		status = (int)(Math.random() * 2);
		if(d2() < 4 * width * width)
			status = 0;
		
		if(wall == null)
		{
			try {
				Image wallSRC = new Image("img/stone_brick.png");
				wall = new SpriteSheet(wallSRC, 16, 16, 2, 0);
				Image floorSRC = new Image("img/dirt_floor.png");
				floor = new SpriteSheet(floorSRC, 16, 16, 2, 0);
				Image crackedSRC = new Image("img/dirt_cracked.png");
				cracked = new SpriteSheet(crackedSRC, 16, 16, 2, 0);
			} catch (SlickException e) {
				e.printStackTrace();
			}
		}
		img = getSprite(status);
		effects = new ArrayList<TileEffect>();
	}
	
	public Cell(int x, int y,  ArrayList<Cell> grid, Cell parent, int direction)//the direction passed should be child->parent
	{
		this(x, y, grid);
		//add the parent cell as a neighbor
		neighbors[direction] = parent;
		//override random color from base constructor to a modified average color of the parent and its neighbors
		if(parent.getStatus() == 0)
			if(parent.neighborStatus(0) < 2)
				this.status = 0;
		img = getSprite(status);
		if(status == 0)
		{
			if(Math.random() < 0.05)
			{
				double rand = Math.random();
				if(rand > 0.97)
					attached = randomItem();
				else
					attached = new Coin();
			}
		}
	}
	
	public String toString()
	{
		return "( " + x + ", " + y + ")";
	}
	
	public void setNeighbor(Cell neighbor, int direction)
	{
		neighbors[direction] = neighbor;
	}
	
	public void update()
	{
		int d2 = d2();
		if(d2 > 900 * width * width)//cells outside a radius of 30 will despawn
			despawn();
		if(d2 < 784 * width * width)//cells inside a radius of 28 will attempt to generate neighboring cells
			genCell();
		img = getSprite(status);
	}
	
	public void updateSprite()
	{
		img = getSprite(status);
	}
	
	public void updateEffects()
	{
		for(int i = 0; i < effects.size(); i++)
			effects.get(i).update();
		for(int i = effects.size() - 1; i >= 0; i--)
			if(effects.get(i).remove())
				effects.remove(i);
	}
	
	private void checkNeighbors()//use this method to check for new neighbors generated by nearby cells
	{
		for(int i = 0; i < 4; i++)
			if(neighbors[i] == null)
				for(int j = 0; j < 4; j++)
					if(neighbors[j] != null)
					{
						Cell neighbor = neighbors[j].poll(getX(i), getY(i), j, 0);//poll a known neighbor about the existence of an unknown neighbor
						if(neighbor != null)//if the poll is successful, add the new neighbor to the neighbors[] list and stop polling neighbors about it
						{
							neighbors[i] = neighbor;
							neighbor.setNeighbor(this, flipDir(i));
							break;
						}
						//reset the debug trackers
						stackTracer.clear();
						stackTracker = "";
					}
		//check to see if a cell has four neighbors based on its updated list
		int count = 0;
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
				count++;
		if(count == 4)//deactivate a cells with four neighbors, as it can not possibly generate additional cells nor can it despawn before one of its neighbors
			active = false;
	}
	
	public Cell poll(int x, int y, int rDir, int stack)//poll a cell about the existence of a cell at (x,y)
	{
		//add this cell to the stack list, and record its depth
		stackTracer.add(this);
		stackTracker += ""+stack;
		if(this.x == x && this.y == y)//if this cell's coordinates match the requested coordinates, return it as a successful result
			return this;
		if(stack > 5)//poll stacks should never go above 3, but this will stop a recursive poll loop to prevent a full crash
		{
			System.out.println("Poll Aborted: Too many stacks!");
			int count = 0;
			int layer = 0;
			//this loop will spit out cell data based on depth in the poll-stack
			while(count < stackTracer.size())
			{
				System.out.print("Layer " + layer + ": ");
				for(int i = 0; i < stackTracker.length(); i++)
					if(Integer.parseInt(stackTracker.substring(i, i+1)) == layer)
					{
						System.out.print(stackTracer.get(i) + "\t");
						count++;
					}
			System.out.println();
				layer++;
			}
			System.out.println();
			//a recursive poll loop = failure, so return null
			return null;
		}
		/*
		Upon recieving a poll query, the cell will compare its own coordinates to those requested and generate up to two directions in the form self->requested along
		the x and y axes.
		*/
		Cell n1 = null;//these are placeholders for potential successful results
		Cell n2 = null;//they are set to null by default in case of an unsuccessful result
		if(x != this.x)//if the requested x coord is not equal to this cells x coord, then we can move along the x axis to get closer to the desired coordinate
		{
			int dir = 3;
			if(x > this.x)
				dir = 1;
			//if this cell has a neighbor in the direction of the requested cell, send it a poll query with the same information
			//make sure that the direction calculated is not the reverse of the direction given by the parent cell, or the request will bounce back and forth
			//and create a stack overflow
			if(neighbors[dir] != null && dir != flipDir(rDir))
				n1 = neighbors[dir].poll(x, y, dir, stack+1);
		}
		if(y != this.y)
		{
			int dir = 0;
			if(y > this.y)
				dir = 2;				
			if(neighbors[dir] != null && dir != flipDir(rDir))			
				n2 = neighbors[dir].poll(x, y, dir, stack+1);			
		}
		//if either poll produced a result, return it
		//otherwise, return null, as this branch of the poll tree has failed
		if(n1 != null)
			return n1;
		if(n2 != null)
			return n2;
		return null;
	}
	
	public boolean isActive()
	{
		return active;
	}
	
	public boolean remove()
	{
		return remove;
	}
	
	public void wake()
	{
		active = true;
	}
	
	public void sleep()
	{
		active = false;
	}
	
	public void collect(Player p)
	{
		if(p.interact(attached))
			attached = null;
		for(int i = 0; i < effects.size(); i++)
			effects.get(i).act(p);
	}
	
	public void act(GridObject o)
	{
		for(int i = 0; i < effects.size(); i++)
			effects.get(i).act(o);
	}
	
	private void despawn()
	{
		//refresh neighbor list so that all relevent cells can be woken
		checkNeighbors();
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
			{
				neighbors[i].wake();//wake neighboring cells since they are near despawn range and need to be active to detect and respond properly
				neighbors[i].setNeighbor(null, flipDir(i));//remove this cell from neighbors' reference list
				//IF YOU DON'T REMOVE REFERENCES YOU WILL GET NASTY, JANKY BUGS
			}
		//mark this cell for removal from the grid
		remove = true;
	}
		
	public boolean contains(int x, int y)//check if the given coordinates are within the on-screen bounds of this cell
	{
		if(x >= this.x && x <= this.x + width)
			if(y >= this.y && y <= this.y + width)
				return true;
		return false;
	}
	public void selectCell(int x, int y)//invoked by the World class on mouse click
	{
//		checkNeighbors();
		if(contains(x,y))
		{
			select = true;
			System.out.println("Neighbors of " + this + ":");
			for(int i = 0; i < 4; i++)
				if(neighbors[i] != null)
				{
					neighbors[i].select();
							System.out.println((i) + ". " + neighbors[i]);
				}
		}
	}
	public void select()
	{
		select = true;
	}
	public void clear()
	{
		select = false;
	}
	
	private void genCell()//used to generate neighbors if a cell is too close to the origin
	{
		//refresh neighbor list to prevent duplicate cells with the same coordinates
		checkNeighbors();
		for(int i = 0; i < 4; i++)
			if(neighbors[i] == null)//if a spot on the reference list is empty, fill it with a new cell
			{
				neighbors[i] = new Cell(getX(i), getY(i), grid, this, flipDir(i));
				grid.add(neighbors[i]);//add the new cell to the grid
			}
		//we could probably deactivate the cell since it has filled out its neighbor list (surrounded itself), but the next update pass should do this anyway
		if(status == 1 && neighborStatus(1) == 0 && !perm)
			status = 0;
		if(status == 0 && neighborStatus(0) == 1 && Math.random() > 0.99)
		{
			if(Math.random() > 0.5)
				attached = new Key();
			else
				attached = new Chest();
		}	}
	
	public void clearStrayBlocks()
	{
		if(status == 1 && neighborStatus(0) > 2 && !perm)
			status = 0;
		if(status == 0 && neighborStatus(0) == 1 && Math.random() > 0.99)
		{
			if(Math.random() > 0.5)
				attached = new Key();
			else
				attached = new Chest();
		}
	}
	
	public void draw(Graphics b)
	{
		if(active)
			color = new Color(1,1,1,0.2f);
		b.drawImage(img, x + World.width / 2, y + World.height / 2, color);	
		color = Color.white;
		for(int i = 0; i < effects.size(); i++)
			effects.get(i).draw(b, x, y);

	}
	
	public void draw(Graphics b, int offX, int offY)
	{
		if(active)
			color = new Color(1,1,1,0.2f);
		b.drawImage(img, x + offX + BaseGame.width / 2, y + offY + BaseGame.height / 2, color);	
		color = Color.white;
		for(int i = 0; i < effects.size(); i++)
			effects.get(i).draw(b, x + offX, y + offY);

	}
	
	public void drawAttached(Graphics b)
	{
		if(attached != null)
			attached.draw(b, x + BaseGame.width / 2, y + BaseGame.height / 2);
	}
	
	public void drawAttached(Graphics b, int offX, int offY)
	{
		if(attached != null)
			attached.draw(b, x + offX + BaseGame.width / 2, y + offY + BaseGame.height / 2);
	}
	
	private Image getSprite(int status)
	{
		if(status == 0)
		{
//			if(effect == 1)
//				return cracked.getSubImage(1 + rx, 1);
			return floor.getSubImage(1 + rx, 1);
		}
		else if(status == 1)
		{
			boolean up = 	(neighbors[0] != null && neighbors[0].getStatus() == 1 );
			boolean right = (neighbors[1] != null && neighbors[1].getStatus() == 1 );
			boolean down = 	(neighbors[2] != null && neighbors[2].getStatus() == 1 );
			boolean left = 	(neighbors[3] != null && neighbors[3].getStatus() == 1 );

			if(neighborStatus(1) == 4)
				return wall.getSubImage(1+rx, 1);
			else if(neighborStatus(1) == 3)
			{
				if(up)
				{
					if(right)
					{
						if(left)
							return wall.getSubImage(1 + rx, 2);	
						return wall.getSubImage(0, rx);	
					}
					return wall.getSubImage(4, rx);
				}
				return wall.getSubImage(1+rx, 0);			
			}
			else if(neighborStatus(1) == 2)
			{
				if(up)
				{
					if(right)
						return wall.getSubImage(2*rx, 4);	
					if(down)
						return wall.getSubImage(5, rx);	
					return wall.getSubImage(1+2*rx, 4);	
				}
				if(left)
				{
					if(right)
						return wall.getSubImage(6+rx, 4);	
					return wall.getSubImage(1+2*rx, 3);	
				}
				return wall.getSubImage(2*rx, 3);			
			}
			else if(neighborStatus(1) == 1)
			{
				if(up)
					return wall.getSubImage(6+rx, 3);
				if(right)
					return wall.getSubImage(9, rx);
				if(down)
					return wall.getSubImage(6+rx, 0);
				return wall.getSubImage(12, rx);

			}
			else
				return wall.getSubImage(9+rx, 3);

		}
		return wall.getSubImage(3, 1);
	}
	
	public boolean checkBounds()
	{
		if(x + width + BaseGame.width / 2 < 0)
			return false;
		if(x - World.width / 2 > BaseGame.width)
			return false;
		if(y + width + BaseGame.height / 2 < 0)
			return false;
		if(y - World.height / 2 > BaseGame.height)
			return false;
		return true;
	}
	
	public static void displayMode(int mode)
	{
		Cell.displayMode = mode;
	}
	
	public Cell getNeighbor(int dir)
	{
		return neighbors[dir];
	}
	
	private int getX(int dir)//returns the expected x-coordinate of the neighboring cell in a given direction
	{
		if(dir == 1)
			return x + width;
		if(dir == 3)
			return x - width;
		return x;
	}
	
	private int getY(int dir)//returns the expected y-coordinate of the neighboring cell in a given direction
	{
		if(dir == 2)
			return y + width;
		if(dir == 0)
			return y - width;
		return y;
	}
	
	public int getX()
	{
		return x;
	}
	
	public int getY()
	{
		return y;
	}
	
	public int getZ()
	{
		return z;
	}
	
	public int d2()
	{
		return x * x + y * y;
	}
	
	public void move(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void setColor(Color color)
	{
		this.color = color;
	}
	public Color getColor()
	{
		return color;
	}
	
	public Color getAVGColor()
	{
		double r = color.getRed();
		double g = color.getGreen();
		double b = color.getBlue();
		int count = 1;
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
			{
				count++;
				r += neighbors[i].getColor().getRed();
				g += neighbors[i].getColor().getGreen();
				b += neighbors[i].getColor().getBlue();
			}	
		return new Color((int)(r/count),(int)(g/count),(int)(b/count));
	}
	
	public int getAVGZ()
	{
		double h = z;
		int count = 1;
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
			{
				count++;
				h += neighbors[i].getZ();
			}
		return (int)(h / count);
	}
	
	public int getCountGreater(int z)
	{
		int count = 0;
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
				if(neighbors[i].getZ() > z)
					count++;
		return count;
	}
	
	private int flipDir(int dir)//returns the reverse of a given direction ie. left->right or up->down
	{
		return (dir + 2) % 4;
	}
	
	private int colorClamp(int raw)//clamps an int value between 0 and 255
	{
		return Math.max(0,Math.min(raw, 255));
	}
	
	public void setStatus(int status)
	{
		this.status = status;
	}
	
	public void setStatus(int status, boolean perm)
	{
		this.status = status;
		this.perm = perm;
	}
	
	public int getStatus()
	{
		return status;
	}
	
	public int neighborStatus(int status)
	{
		int count = 0;
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
				if(neighbors[i].getStatus() == status)
					count++;
		return count;	
	}
	
	public void updateNeighbors()
	{
		for(int i = 0; i < 4; i++)
			if(neighbors[i] != null)
				neighbors[i].update();
	}
	
	public void addEffect(TileEffect effect)
	{
		if(effects.size() == 0)
			effects.add(effect);
		for(int i = 0; i < effects.size(); i++)
		{
			if(effects.get(i).getType() == effect.getType())
			{
				effects.add(i, effect);
				effects.remove(i+1);
				break;
			}
			else if(effects.get(i).getType() > effect.getType())
			{
				effects.add(i, effect);
				break;
			}
		}
	}
	
	public void clearEffects()
	{
		effects.clear();
	}
	
	public void clearAttachment()
	{
		attached = null;
	}
	
	public static Attachment randomItem()
	{
		double rand = Math.random();
		int numItems = 4;
		double prop = 1.0 / numItems;
		if(rand < prop)
			return new Blast();
		if(rand < 2 * prop)
			return new Freeze();
		if(rand < 3 *prop)
			return new Teleport();
		return new StoneMason();
	}
}